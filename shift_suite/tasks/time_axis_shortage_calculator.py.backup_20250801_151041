#!/usr/bin/env python3
"""
æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹ä¸è¶³æ™‚é–“è¨ˆç®—ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
æŒ‰åˆ†è¨ˆç®—ã«ä»£ã‚ã‚‹çœŸã®åˆ†æä¾¡å€¤ã‚’æŒã¤è¨ˆç®—æ‰‹æ³•
"""

from typing import Dict, List, Tuple, Optional
import pandas as pd
import numpy as np
import logging
from datetime import datetime, time, timedelta
from collections import defaultdict

log = logging.getLogger(__name__)

class TimeAxisShortageCalculator:
    """
    æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹ä¸è¶³æ™‚é–“è¨ˆç®—ã‚¯ãƒ©ã‚¹
    å‹•çš„ã‚¹ãƒ­ãƒƒãƒˆé–“éš”ã§ã®çœŸã®éä¸è¶³åˆ†æ
    æŒ‰åˆ†è¨ˆç®—ã®ç·ä¸è¶³æ™‚é–“ã‚’ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ã¨ã—ãŸç¾å®Ÿçš„ãªè¨ˆç®—
    """
    
    def __init__(self, slot_hours: float = 0.5, slot_minutes: int = 30, auto_detect: bool = True, 
                 total_shortage_baseline: float = None):
        self.slot_hours = slot_hours
        self.slot_minutes = slot_minutes
        self.auto_detect = auto_detect
        self.detected_slot_info = None
        self.total_shortage_baseline = total_shortage_baseline  # æŒ‰åˆ†è¨ˆç®—ã®ç·ä¸è¶³æ™‚é–“
        
    def calculate_role_based_shortage(
        self, 
        actual_data: pd.DataFrame,
        need_data: pd.DataFrame
    ) -> Dict[str, Dict]:
        """
        è·ç¨®åˆ¥ã®æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹ä¸è¶³æ™‚é–“è¨ˆç®—
        
        Args:
            actual_data: å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿ (staff, role, ds, parsed_slots_countåˆ—ã‚’å«ã‚€)
            need_data: éœ€è¦ãƒ‡ãƒ¼ã‚¿ (æ—¥ä»˜Ã—æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã®éœ€è¦)
            
        Returns:
            è·ç¨®åˆ¥ä¸è¶³æ™‚é–“åˆ†æçµæœ
        """
        role_analysis = {}
        
        # å‹¤å‹™ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ã¿æŠ½å‡º
        work_records = actual_data[actual_data['parsed_slots_count'] > 0].copy()
        
        if work_records.empty:
            log.warning("[TimeAxis] å‹¤å‹™ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return {}
        
        # å‹•çš„ã‚¹ãƒ­ãƒƒãƒˆæ¤œå‡º
        if self.auto_detect and 'ds' in work_records.columns:
            self._detect_and_update_slot_interval(work_records['ds'])
        
        # è·ç¨®ã”ã¨ã«åˆ†æ
        for role in work_records['role'].unique():
            if not role or role == '':
                continue
                
            role_records = work_records[work_records['role'] == role]
            
            # è·ç¨®åˆ¥ä¾›çµ¦é‡ã‚’æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆåˆ¥ã«é›†è¨ˆ
            role_supply = self._aggregate_supply_by_timeslot(role_records)
            
            # è·ç¨®åˆ¥å®Ÿåƒãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
            working_patterns = self._analyze_working_patterns(role_records)
            
            # éœ€è¦ã¨ã®æ¯”è¼ƒï¼ˆè·ç¨®ãŒå¯¾å¿œã™ã‚‹æ™‚é–“å¸¯ã§ã®éœ€è¦ï¼‰
            # ğŸ¯ ä¿®æ­£: è·ç¨®ã®å…¨ä½“ã«ãŠã‘ã‚‹ä¾›çµ¦å‰²åˆã‚’è¨ˆç®—
            total_records = len(work_records)
            role_records_count = len(role_records)
            role_supply_ratio = role_records_count / max(total_records, 1)
            
            demand_coverage = self._calculate_demand_coverage(
                role_supply, need_data, working_patterns, role_supply_ratio
            )
            
            # ğŸ¯ ä¿®æ­£: å®Ÿéš›ã®åŠ´åƒæ™‚é–“ã‚’æ­£ç¢ºã«è¨ˆç®—
            actual_work_hours = role_records['parsed_slots_count'].sum() * self.slot_hours
            
            role_analysis[role] = {
                'total_work_hours': actual_work_hours,
                'unique_staff': role_records['staff'].nunique(),
                'working_patterns': working_patterns,
                'supply_by_timeslot': role_supply,
                'demand_coverage': demand_coverage,
                'shortage_hours': demand_coverage.get('total_shortage', 0),
                'excess_hours': demand_coverage.get('total_excess', 0),
                'efficiency_ratio': demand_coverage.get('efficiency_ratio', 0)
            }
            
        log.info(f"[TimeAxis] è·ç¨®åˆ¥åˆ†æå®Œäº†: {len(role_analysis)}è·ç¨®")
        return role_analysis
    
    def calculate_employment_based_shortage(
        self, 
        actual_data: pd.DataFrame,
        need_data: pd.DataFrame,
        cost_per_hour: Optional[Dict[str, float]] = None
    ) -> Dict[str, Dict]:
        """
        é›‡ç”¨å½¢æ…‹åˆ¥ã®æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹ä¸è¶³æ™‚é–“è¨ˆç®—
        
        Args:
            actual_data: å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿
            need_data: éœ€è¦ãƒ‡ãƒ¼ã‚¿
            cost_per_hour: é›‡ç”¨å½¢æ…‹åˆ¥æ™‚é–“å˜ä¾¡ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            
        Returns:
            é›‡ç”¨å½¢æ…‹åˆ¥ä¸è¶³æ™‚é–“åˆ†æçµæœ
        """
        employment_analysis = {}
        
        # å‹¤å‹™ãƒ¬ã‚³ãƒ¼ãƒ‰ã®ã¿æŠ½å‡º
        work_records = actual_data[actual_data['parsed_slots_count'] > 0].copy()
        
        if work_records.empty:
            log.warning("[TimeAxis] å‹¤å‹™ãƒ¬ã‚³ãƒ¼ãƒ‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
            return {}
        
        # å‹•çš„ã‚¹ãƒ­ãƒƒãƒˆæ¤œå‡ºï¼ˆå½¹å‰²ãƒ™ãƒ¼ã‚¹åˆ†æã¨å…±æœ‰ï¼‰
        if self.auto_detect and 'ds' in work_records.columns:
            self._detect_and_update_slot_interval(work_records['ds'])
        
        # é›‡ç”¨å½¢æ…‹ã”ã¨ã«åˆ†æ
        for employment in work_records['employment'].unique():
            if not employment or employment == '':
                continue
                
            emp_records = work_records[work_records['employment'] == employment]
            
            # é›‡ç”¨å½¢æ…‹åˆ¥ä¾›çµ¦é‡ã‚’æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆåˆ¥ã«é›†è¨ˆ
            emp_supply = self._aggregate_supply_by_timeslot(emp_records)
            
            # é›‡ç”¨å½¢æ…‹åˆ¥å®Ÿåƒãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ
            working_patterns = self._analyze_working_patterns(emp_records)
            
            # éœ€è¦ã¨ã®æ¯”è¼ƒ
            # ğŸ¯ ä¿®æ­£: é›‡ç”¨å½¢æ…‹ã®å…¨ä½“ã«ãŠã‘ã‚‹ä¾›çµ¦å‰²åˆã‚’è¨ˆç®—
            total_records = len(work_records)
            emp_records_count = len(emp_records)
            emp_supply_ratio = emp_records_count / max(total_records, 1)
            
            demand_coverage = self._calculate_demand_coverage(
                emp_supply, need_data, working_patterns, emp_supply_ratio
            )
            
            # ã‚³ã‚¹ãƒˆåŠ¹ç‡åˆ†æï¼ˆæ™‚é–“å˜ä¾¡ãŒæä¾›ã•ã‚ŒãŸå ´åˆï¼‰
            cost_efficiency = {}
            if cost_per_hour and employment in cost_per_hour:
                hourly_cost = cost_per_hour[employment]
                total_cost = len(emp_records) * self.slot_hours * hourly_cost
                cost_efficiency = {
                    'hourly_cost': hourly_cost,
                    'total_cost': total_cost,
                    'cost_per_shortage_hour': total_cost / max(demand_coverage.get('total_shortage', 1), 1),
                    'cost_effectiveness': demand_coverage.get('efficiency_ratio', 0) / max(hourly_cost, 1)
                }
            
            # ğŸ¯ ä¿®æ­£: å®Ÿéš›ã®åŠ´åƒæ™‚é–“ã‚’æ­£ç¢ºã«è¨ˆç®—
            actual_work_hours = emp_records['parsed_slots_count'].sum() * self.slot_hours
            
            employment_analysis[employment] = {
                'total_work_hours': actual_work_hours,
                'unique_staff': emp_records['staff'].nunique(),
                'working_patterns': working_patterns,
                'supply_by_timeslot': emp_supply,
                'demand_coverage': demand_coverage,
                'shortage_hours': demand_coverage.get('total_shortage', 0),
                'excess_hours': demand_coverage.get('total_excess', 0),
                'efficiency_ratio': demand_coverage.get('efficiency_ratio', 0),
                'cost_efficiency': cost_efficiency
            }
            
        log.info(f"[TimeAxis] é›‡ç”¨å½¢æ…‹åˆ¥åˆ†æå®Œäº†: {len(employment_analysis)}å½¢æ…‹")
        return employment_analysis
    
    def _aggregate_supply_by_timeslot(self, records: pd.DataFrame) -> Dict[str, float]:
        """ãƒ¬ã‚³ãƒ¼ãƒ‰ã‚’æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆåˆ¥ã«ä¾›çµ¦é‡ã‚’é›†è¨ˆï¼ˆé‡è¤‡ã‚«ã‚¦ãƒ³ãƒˆé˜²æ­¢ï¼‰"""
        supply_by_slot = defaultdict(float)
        
        # ğŸ¯ ä¿®æ­£: åŒä¸€æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã®é‡è¤‡ã‚«ã‚¦ãƒ³ãƒˆã‚’é˜²æ­¢
        # æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆåˆ¥ã«äººæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆã—ã¦ã€å®Ÿéš›ã®åŠ´åƒåŠ›ã‚’æ­£ç¢ºã«è¨ˆç®—
        for _, record in records.iterrows():
            time_slot = record['ds'].strftime("%H:%M")
            # parsed_slots_countãŒ1ä»¥ä¸Šã®å ´åˆã®ã¿ã‚«ã‚¦ãƒ³ãƒˆï¼ˆå®Ÿéš›ã®å‹¤å‹™æ™‚é–“ï¼‰
            if record.get('parsed_slots_count', 0) > 0:
                supply_by_slot[time_slot] += record['parsed_slots_count'] * self.slot_hours
            
        return dict(supply_by_slot)
    
    def _analyze_working_patterns(self, records: pd.DataFrame) -> Dict:
        """å‹¤å‹™ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è©³ç´°åˆ†æ"""
        
        # æ™‚é–“å¸¯åˆ¥åˆ†å¸ƒ
        time_distribution = defaultdict(int)
        for _, record in records.iterrows():
            hour = record['ds'].hour
            time_distribution[hour] += 1
        
        # ãƒ”ãƒ¼ã‚¯æ™‚é–“å¸¯ã®ç‰¹å®š
        peak_hours = sorted(time_distribution.items(), 
                          key=lambda x: x[1], reverse=True)[:3]
        
        # å‹¤å‹™æ™‚é–“å¸¯ã®ç¯„å›²
        all_hours = sorted(time_distribution.keys())
        working_span = f"{min(all_hours)}:00-{max(all_hours)}:00" if all_hours else "No data"
        
        # è·å“¡ã®å‹¤å‹™é »åº¦åˆ†æ
        staff_frequency = records['staff'].value_counts()
        
        return {
            'time_distribution': dict(time_distribution),
            'peak_hours': peak_hours,
            'working_span': working_span,
            'total_slots': len(records),
            'staff_count': records['staff'].nunique(),
            'avg_slots_per_staff': len(records) / max(records['staff'].nunique(), 1),
            'most_active_staff': staff_frequency.head(3).to_dict()
        }
    
    def _calculate_demand_coverage(
        self, 
        supply_by_slot: Dict[str, float],
        need_data: pd.DataFrame,
        working_patterns: Dict,
        role_supply_ratio: float = 1.0
    ) -> Dict:
        """éœ€è¦ã‚«ãƒãƒ¬ãƒƒã‚¸åˆ†æï¼ˆç¾å®Ÿçš„ãªéœ€è¦è¨ˆç®—ï¼‰"""
        
        total_supply = sum(supply_by_slot.values())
        
        # ğŸ¯ ä¿®æ­£: æœŸé–“ä¾å­˜æ€§å•é¡Œã‚’è€ƒæ…®ã—ãŸç¾å®Ÿçš„ãªéœ€è¦è¨ˆç®—
        if self.total_shortage_baseline and self.total_shortage_baseline > 0:
            # ğŸ” ç•°å¸¸å€¤ãƒã‚§ãƒƒã‚¯: ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ãŒç•°å¸¸ã«å¤§ãã„å ´åˆã®å¯¾å‡¦
            baseline_per_day = self.total_shortage_baseline / max(len(supply_by_slot), 1)
            
            if baseline_per_day > 500:  # 1æ—¥500æ™‚é–“ä»¥ä¸Šã¯ç•°å¸¸
                log.warning(f"[TimeAxis] ç•°å¸¸ãªãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³æ¤œå‡º: {baseline_per_day:.0f}æ™‚é–“/æ—¥")
                log.warning(f"[TimeAxis] æœŸé–“ä¾å­˜æ€§å•é¡Œã®å¯èƒ½æ€§ â†’ ä¿å®ˆçš„ãªéœ€è¦æ¨å®šã«åˆ‡ã‚Šæ›¿ãˆ")
                # ç•°å¸¸å€¤ã®å ´åˆã¯ä¾›çµ¦é‡ãƒ™ãƒ¼ã‚¹ã§æ§ãˆã‚ã«æ¨å®š
                estimated_demand = total_supply * 1.2  # 20%ã®ãƒãƒ¼ã‚¸ãƒ³ã®ã¿
            elif baseline_per_day > 100:  # 1æ—¥100æ™‚é–“ä»¥ä¸Šã¯è¦æ³¨æ„
                log.warning(f"[TimeAxis] é«˜ã„ãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³: {baseline_per_day:.0f}æ™‚é–“/æ—¥ â†’ ç¸®å°é©ç”¨")
                # é«˜ã„å ´åˆã¯ç¸®å°ã—ã¦é©ç”¨
                reduced_baseline = self.total_shortage_baseline * 0.3  # 30%ã«ç¸®å°
                estimated_demand = total_supply + (reduced_baseline * role_supply_ratio)
            else:
                # æ­£å¸¸ç¯„å›²å†…ãªã‚‰å¾“æ¥é€šã‚Š
                log.info(f"[TimeAxis] æ­£å¸¸ãªãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³: {baseline_per_day:.0f}æ™‚é–“/æ—¥")
                estimated_demand = total_supply + (self.total_shortage_baseline * role_supply_ratio * 0.5)  # 50%ã«ç¸®å°
        else:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ä¾›çµ¦ã¨ã»ã¼åŒç­‰ã®éœ€è¦ï¼ˆéåº¦ãªå¢—å¤§ã‚’é˜²æ­¢ï¼‰
            estimated_demand = total_supply * 1.05  # 5%ã®ä½™è£•ã®ã¿
        
        shortage = max(0, estimated_demand - total_supply)
        excess = max(0, total_supply - estimated_demand)
        efficiency_ratio = total_supply / max(estimated_demand, 1)
        
        return {
            'total_demand': estimated_demand,
            'total_supply': total_supply,
            'total_shortage': shortage,
            'total_excess': excess,
            'efficiency_ratio': efficiency_ratio,
            'coverage_ratio': min(1.0, efficiency_ratio)
        }
        
    def _detect_and_update_slot_interval(self, timestamp_data: pd.Series) -> None:
        """ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚¹ãƒ­ãƒƒãƒˆé–“éš”ã‚’è‡ªå‹•æ¤œå‡ºãƒ»æ›´æ–°"""
        
        if timestamp_data.empty:
            return
        
        # åˆ†ã®å€¤ã‚’æŠ½å‡ºã—ã¦åˆ†æ
        minutes_set = set()
        for timestamp in timestamp_data.dropna():
            minutes_set.add(timestamp.minute)
        
        minutes_list = sorted(list(minutes_set))
        
        # ä¸€èˆ¬çš„ãªã‚¹ãƒ­ãƒƒãƒˆé–“éš”ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç¢ºèª
        slot_patterns = {
            15: [0, 15, 30, 45],
            30: [0, 30],
            60: [0],
            20: [0, 20, 40],
            10: [0, 10, 20, 30, 40, 50]
        }
        
        best_match = None
        best_score = 0.0
        
        for slot_min, pattern in slot_patterns.items():
            # ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®ä¸€è‡´åº¦ã‚’è¨ˆç®—
            matches = len(set(minutes_list) & set(pattern))
            total = len(set(minutes_list) | set(pattern))
            score = matches / total if total > 0 else 0.0
            
            if score > best_score:
                best_score = score
                best_match = slot_min
        
        # ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯30åˆ†
        if best_match is None or best_score < 0.5:
            best_match = 30
            best_score = 0.5
        
        # ã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±ã‚’æ›´æ–°
        self.slot_minutes = best_match
        self.slot_hours = best_match / 60.0
        
        self.detected_slot_info = {
            'slot_minutes': best_match,
            'slot_hours': best_match / 60.0,
            'confidence': best_score,
            'detected_pattern': slot_patterns.get(best_match, [0, 30]),
            'actual_minutes': minutes_list
        }
        
        log.info(f"[TimeAxis] å‹•çš„ã‚¹ãƒ­ãƒƒãƒˆæ¤œå‡º: {best_match}åˆ† (ä¿¡é ¼åº¦: {best_score:.2f})")
    
    def get_detected_slot_info(self) -> Optional[Dict]:
        """æ¤œå‡ºã•ã‚ŒãŸã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±ã‚’å–å¾—"""
        return self.detected_slot_info

def create_time_axis_replacement():
    """æŒ‰åˆ†è¨ˆç®—ã®ç½®ãæ›ãˆç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°"""
    
    def calculate_time_axis_shortage(
        working_data: pd.DataFrame, 
        need_data: Optional[pd.DataFrame] = None,
        total_shortage_baseline: float = None
    ) -> Tuple[Dict[str, float], Dict[str, float]]:
        """
        æŒ‰åˆ†è¨ˆç®—ã®ä»£æ›¿ã¨ã—ã¦æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹è¨ˆç®—ã‚’å®Ÿè¡Œï¼ˆç¾å®Ÿçš„ãªè¨ˆç®—ï¼‰
        
        Args:
            working_data: å‹¤å‹™ãƒ‡ãƒ¼ã‚¿
            need_data: éœ€è¦ãƒ‡ãƒ¼ã‚¿ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            total_shortage_baseline: æŒ‰åˆ†è¨ˆç®—ã®ç·ä¸è¶³æ™‚é–“ï¼ˆãƒ™ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ³ï¼‰
            
        Returns:
            (è·ç¨®åˆ¥ä¸è¶³æ™‚é–“è¾æ›¸, é›‡ç”¨å½¢æ…‹åˆ¥ä¸è¶³æ™‚é–“è¾æ›¸)
        """
        calculator = TimeAxisShortageCalculator(
            auto_detect=True, 
            total_shortage_baseline=total_shortage_baseline
        )
        
        # è·ç¨®åˆ¥åˆ†æ
        role_analysis = calculator.calculate_role_based_shortage(
            working_data, need_data or pd.DataFrame()
        )
        
        # é›‡ç”¨å½¢æ…‹åˆ¥åˆ†æ
        employment_analysis = calculator.calculate_employment_based_shortage(
            working_data, need_data or pd.DataFrame()
        )
        
        # æŒ‰åˆ†è¨ˆç®—äº’æ›å½¢å¼ã§å‡ºåŠ›
        role_shortages = {
            role: data['shortage_hours'] 
            for role, data in role_analysis.items()
        }
        
        employment_shortages = {
            employment: data['shortage_hours'] 
            for employment, data in employment_analysis.items()
        }
        
        # æ¤œå‡ºã•ã‚ŒãŸã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›
        slot_info = calculator.get_detected_slot_info()
        if slot_info:
            log.info(f"[TimeAxis] æ¤œå‡ºã‚¹ãƒ­ãƒƒãƒˆ: {slot_info['slot_minutes']}åˆ† (ä¿¡é ¼åº¦: {slot_info['confidence']:.2f})")
        
        log.info(f"[TimeAxis] æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹è¨ˆç®—å®Œäº†: è·ç¨®{len(role_shortages)}å€‹, é›‡ç”¨å½¢æ…‹{len(employment_shortages)}å€‹")
        
        return role_shortages, employment_shortages
    
    return calculate_time_axis_shortage

# æ—¢å­˜ã‚³ãƒ¼ãƒ‰ã¨ã®äº’æ›æ€§ã®ãŸã‚ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹
calculate_time_axis_shortage = create_time_axis_replacement()

# ãƒ†ã‚¹ãƒˆç”¨ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
def generate_sample_data() -> Tuple[pd.DataFrame, pd.DataFrame]:
    """ãƒ†ã‚¹ãƒˆç”¨ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ"""
    
    # ã‚µãƒ³ãƒ—ãƒ«å®Ÿç¸¾ãƒ‡ãƒ¼ã‚¿
    sample_actual = pd.DataFrame({
        'staff': ['ç”°ä¸­', 'ä½è—¤', 'éˆ´æœ¨'] * 10,
        'role': ['çœ‹è­·å¸«', 'ä»‹è­·å£«', 'äº‹å‹™'] * 10,
        'employment': ['å¸¸å‹¤', 'ãƒ‘ãƒ¼ãƒˆ', 'ã‚¹ãƒãƒƒãƒˆ'] * 10,
        'ds': pd.date_range('2025-01-01 08:00', periods=30, freq='30min'),
        'parsed_slots_count': [1] * 30
    })
    
    # ã‚µãƒ³ãƒ—ãƒ«éœ€è¦ãƒ‡ãƒ¼ã‚¿ï¼ˆç©ºã®DataFrameï¼‰
    sample_need = pd.DataFrame()
    
    return sample_actual, sample_need

if __name__ == "__main__":
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    print("=== æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹ä¸è¶³æ™‚é–“è¨ˆç®—ãƒ†ã‚¹ãƒˆ ===")
    
    actual_data, need_data = generate_sample_data()
    
    calculator = TimeAxisShortageCalculator()
    
    # è·ç¨®åˆ¥åˆ†æ
    role_results = calculator.calculate_role_based_shortage(actual_data, need_data)
    print(f"\nè·ç¨®åˆ¥åˆ†æçµæœ:")
    for role, data in role_results.items():
        print(f"  {role}: ä¸è¶³{data['shortage_hours']:.1f}h, åŠ¹ç‡{data['efficiency_ratio']:.2f}")
    
    # æŒ‰åˆ†è¨ˆç®—ä»£æ›¿ãƒ†ã‚¹ãƒˆ
    role_shortages, emp_shortages = calculate_time_axis_shortage(actual_data)
    print(f"\næŒ‰åˆ†è¨ˆç®—ä»£æ›¿çµæœ:")
    print(f"  è·ç¨®åˆ¥: {role_shortages}")
    print(f"  é›‡ç”¨å½¢æ…‹åˆ¥: {emp_shortages}")